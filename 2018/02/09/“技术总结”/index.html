<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>“技术总结” | 邸建楠</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="javascript的组成ECMAscript(5.1)核心 javascript组成语言的语法和基本对象                        语法、类型、语句、关键字、保留字、操作符、对象DOM文档对象模型     描述处理网页内容的方法和接口BOM浏览器对象模型   描述与浏览器进行交互的方法和接口 JS 特点：跨平台的WEB脚本语言  window Mac pc端   移动端  安">
<meta property="og:type" content="article">
<meta property="og:title" content="“技术总结”">
<meta property="og:url" content="http://yoursite.com/2018/02/09/“技术总结”/index.html">
<meta property="og:site_name" content="邸建楠">
<meta property="og:description" content="javascript的组成ECMAscript(5.1)核心 javascript组成语言的语法和基本对象                        语法、类型、语句、关键字、保留字、操作符、对象DOM文档对象模型     描述处理网页内容的方法和接口BOM浏览器对象模型   描述与浏览器进行交互的方法和接口 JS 特点：跨平台的WEB脚本语言  window Mac pc端   移动端  安">
<meta property="og:image" content="http://yoursite.com/2018/02/09/“技术总结”/001.jpg">
<meta property="og:updated_time" content="2018-02-09T14:49:25.551Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="“技术总结”">
<meta name="twitter:description" content="javascript的组成ECMAscript(5.1)核心 javascript组成语言的语法和基本对象                        语法、类型、语句、关键字、保留字、操作符、对象DOM文档对象模型     描述处理网页内容的方法和接口BOM浏览器对象模型   描述与浏览器进行交互的方法和接口 JS 特点：跨平台的WEB脚本语言  window Mac pc端   移动端  安">
<meta name="twitter:image" content="http://yoursite.com/2018/02/09/“技术总结”/001.jpg">
  
    <link rel="alternate" href="/atom.xml" title="邸建楠" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">邸建楠</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-“技术总结”" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/09/“技术总结”/" class="article-date">
  <time datetime="2018-02-09T13:47:53.000Z" itemprop="datePublished">2018-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      “技术总结”
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>javascript的组成<br>ECMAscript(5.1)核心 javascript组成语言的语法和基本对象<br>                        语法、类型、语句、关键字、保留字、操作符、对象<br>DOM文档对象模型     描述处理网页内容的方法和接口<br>BOM浏览器对象模型   描述与浏览器进行交互的方法和接口</p>
<p>JS 特点：<br>跨平台的WEB脚本语言  window Mac pc端   移动端  安卓系统  ios系统<br>向HTML页面添加交互行为<br>可与服务器进行通讯</p>
<p>js的内容 必须写在script标签内 双标签<br>输出方式<br> alert();  括号里边写输出的内容   除了数字不加引号以外   其他的都要加引号  双引号  单引号都可以<br> document.write(); </p>
<h2 id="console-log-在控制台打印"><a href="#console-log-在控制台打印" class="headerlink" title=" console.log();//在控制台打印"></a> console.log();//在控制台打印</h2><p> js的引入方式<br> 内部脚本块  一般写在body head部分<br> 外部脚本块  引入外部文件 <script src="文件路径"></script>  src的路径里边不允许出现中文<br> 外部脚本块的script标签内是不允许放内容的，可以重新写个script标签</p>
<p> 行间<br> onclick=””<br> 特点  写的比较简单，但是重复率太高，不利于后期维护</p>
<p> 内嵌<br> 特点：可以把样式和结构分离出来，但是我们写的代码只能在当前页面使用，其他的页面并不能用</p>
<p> 外链</p>
<h2 id="特点：多个文件可以公用一个js文件，提高效率"><a href="#特点：多个文件可以公用一个js文件，提高效率" class="headerlink" title=" 特点：多个文件可以公用一个js文件，提高效率"></a> 特点：多个文件可以公用一个js文件，提高效率</h2><p><button id="btn" onclick="dianji()">按钮</button><br>注意：行间中添加事件   onclick 点击事件，onclick=”自定义命名()” 自定义命名一定不能是中文<br>也不建议用纯数字，可以是全英文，也可以英文加数字</p>
<p>完成需求代码分析<br>// 单行注释<br>/**/多行注释<br>通过id获取页面的元素<br>docment.getElementById(“id名称”); 以分号结束<br>给元素添加事件处理，事件有很多种，我们后期学<br>元素.onclick=function(){}<br>docment.getElementById(“id名称”).onclick=function(){}<br>改变函数的样式，行间中操作<br>元素.style.background=值;  值记得加引号，有单位的加单位</p>
<h2 id="document-getElementById-“btn”-style-background-”-f00”"><a href="#document-getElementById-“btn”-style-background-”-f00”" class="headerlink" title="document.getElementById(“btn”).style.background=”#f00”;"></a>document.getElementById(“btn”).style.background=”#f00”;</h2><p>window.onload<br>页面上的代码加载顺序都是从上到下的</p>
<ul>
<li>window.onload 页面加载</li>
<li>window.onload=function(){</li>
<li>//当前页面中的元素全部加载完成后执行这里的代码</li>
<li>}</li>
<li>考虑一下什么时候要用window.onload?</li>
<li>当js代码需要获取页面中的元素的时候，如果script标签放在元素的上面，那就需要加window.onload,</li>
<li>如果在元素的下面，就不需要了</li>
</ul>
<hr>
<p>变量命名的规则</p>
<ul>
<li>1.允许是字母 数字  下划线_ 美元$ 任意组合而成</li>
<li>2.不允许数字开头  </li>
<li>3.不允许使用关键字和保留字</li>
<li>关键字   当前语法中正在使用的单词  var  break  case delete</li>
<li><a href="http://www.w3cschool.com.cn/js/pro_js_keywords.asp" target="_blank" rel="noopener">http://www.w3cschool.com.cn/js/pro_js_keywords.asp</a></li>
<li>保留字   将来可能在语法中使用的单词</li>
<li>变量命名的一个规定</li>
<li>见名知意   写的变量名尽量贴近实际的意思</li>
<li>nav  page  btn  password  studentName   studentAge</li>
<li>aa  bb  cc dd  11 22 33</li>
<li>驼峰命名法</li>
<li>大驼峰</li>
<li>首字母是大写的  Math  Data</li>
<li>小驼峰</li>
<li>第二个单词开始首字母大写</li>
<li>getElementById<br>如果你在声明一个变量以后没有赋值  打印的结果undefined  </li>
</ul>
<h2 id="JavaScript-对大小写是敏感的，包括变量、函数名和操作符都是区分大小写的。例如：text-和-Text-表示两种不同的变量。"><a href="#JavaScript-对大小写是敏感的，包括变量、函数名和操作符都是区分大小写的。例如：text-和-Text-表示两种不同的变量。" class="headerlink" title="JavaScript 对大小写是敏感的，包括变量、函数名和操作符都是区分大小写的。例如：text 和 Text 表示两种不同的变量。"></a>JavaScript 对大小写是敏感的，包括变量、函数名和操作符都是区分大小写的。例如：text 和 Text 表示两种不同的变量。</h2><p>day01作业<br>实例要求：1.点击页面中的按钮，按钮背景色变成其他颜色<br>         2.点击页面中的按钮，改变div的宽度和高度 背景<br>         3.点击页面中的按钮，改变p标签的内容<br>第二个作业 ：两个按钮  点击任何一个按钮 改变DIV的 宽  高   margin padding  背景色<br>           分析<br>           要获取两个按钮  div</p>
<pre><code>给两个按钮添加点击事件，在事件里改变box的属性
</code></pre><hr>
<ul>
<li>函数</li>
<li>js中的函数起一个作用  复用代码</li>
<li>变量也有复用代码的作用</li>
<li></li>
<li>函数的复用是多行代码</li>
<li></li>
<li>函数的定义     函数名是自定义的  在命名的时候遵循的是变量的命名规则</li>
<li></li>
<li>关键字    function  函数名(){</li>
<li>//这里面的代码是复用代码，可以放多行代码</li>
<li>}</li>
<li>函数名();</li>
<li>命名函数写完以后必须调用，如果你不调用的话，计算机是不识别的   </li>
<li>匿名函数<br>*/<br>//命名函数，有函数名   有调用<br>function fnName(){<br> alert(123);<br> var a=10;<br> var b=20;<br> console.log(a+b);<br>}<br>fnName();</li>
</ul>
<hr>
<ul>
<li>函数分为命名函数和匿名函数</li>
<li>匿名函数 没有名字的函数</li>
<li>匿名函数怎么调用？两个条件</li>
<li>1.当匿名函数是以赋值的形式所出现的=并且是被事件所调用的</li>
<li>事件</li>
<li>window.onload  元素.onclick</li>
<li>赋值</li>
<li>=</li>
<li><p>匿名函数是不能直接声明的，直接声明会报错<br>window.onload=function(){}</p>
<p>函数调用</p>
</li>
</ul>
<hr>
<p>type  是属性，属性是这个标签下的东西，描述功能性的一些东西</p>
<ul>
<li></li>
<li>js属性操作方式</li>
<li>1   点  . 的</li>
<li>元素.属性名   获取的结果是他的属性值</li>
<li>如果属性是单一属性，用点操作符取不到的，而且会报错</li>
<li>如果想用点操作符去获取戴横杠的属性，那首先要把横杠去掉，然后把横杠后的第一个字母大写</li>
<li>2.[] 的</li>
<li>中括号代替点，里边可以放带横杠的属性,也可以放不带横杠的属性</li>
<li>如果属性中带横杠，用[]的方式进行属性操作</li>
<li></li>
<li><p>font-size这种属性我们成为它是不符合变量命名规则，只要是这种我们都可以用[]来获取属性<br>.<br>[] - 符合和不符合命名规则的都可以写在中括号里边<br>除了获取属性以外我们还可以设置属性<br>var btn=document.getElementById(“btn”);<br>console.log(btn.type);<br>console.log(btn.id);<br>console.log(btn.name);<br>console.log(btn.value);<br>console.log(btn.style.width);<br>console.log(btn.style.height);<br>console.log(btn.style[‘font-size’]);<br>console.log(btn.style.fontSize);<br>设置属性<br>btn.style.width=”200px”;<br>btn.type=”text”;<br>btn.value=””;可以写中文  可以写英文   </p>
<p>value<br>innerHTML 获取到的是所有的内容<br>className html里写的是class,这个class是保留字，不允许用它，用className<br><div class="cla" id="cla"></div><br><script type="text/javascript"></p>
<pre><code>var c=document.getElementById(&quot;cla&quot;);
console.log(c.className);
</code></pre><p></script><br>href 和  src 取到的值是绝对路径  虽然在网页中可以打开  但是我们不能用它来做判断的<br><img src="001.jpg" id="pic"><br><a href="0104.html" id="link"></a><br><script type="text/javascript"><br>   var pic=document.getElementById(“pic”);<br>   var link=document.getElementById(“link”);<br>   console.log(pic.src);<br>   console.log(link.href);</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></script></p><p>属性案例</p>
</li>
<li>需求  </li>
<li>点击按钮获取输入框中的属性名称和属性值，对div进行设置</li>
<li>1.获取输入框  按钮  div</li>
<li>2.给按钮添加点击事件</li>
<li>3.获取到输入框的内容</li>
<li>4.改变box的样式</li>
<li></li>
<li>点操作属性的时候，后面只能跟真正的属性名称  width height value background fontSize 不能跟变量名</li>
<li>当点后面不能跟变量名的时候，我们用[]来代替</li>
<li>[]中括号里如果放的是真正的属性名，那就要加引号</li>
<li>如果是变量名，那就不需要加引号</li>
<li></li>
<li></li>
<li>var val=txt1.value;</li>
<li>var 变量名=值；</li>
</ul>
<hr>
<ul>
<li>javascript 数据类型分为简单数据类型（基本数据类型）和复杂数据类型（引用数据类型）</li>
<li></li>
<li>简单数据类型（基本数据类型）</li>
<li>String  Number Boolean Null Undefined</li>
<li></li>
<li>复杂数据类型（引用数据类型）</li>
<li>Object 对象（函数。数组  日期 对象）</li>
<li></li>
<li>String  字符串</li>
<li></li>
<li>放在一对单引号或者双引号里，由0个或多个字符组成的串</li>
<li>注意</li>
<li>引号是成对出现的 </li>
<li>如果字符串里面有引号，那外面的引号一定要与里面的引号相反</li>
<li>当两个引号一样的时候加反斜杠，这种方法叫转译  +符号</li>
<li></li>
<li>字符串的拼接</li>
<li>变量和字符串的拼接</li>
<li><ul>
<li>在js有两种含义</li>
</ul>
</li>
<li>1.数学中的加法运算</li>
<li>2.字符串拼接，当加号一边有一个是字符串的时候，它起连接作用</li>
<li>当它两边都是数字类型的时候，那它就是数学运算</li>
<li></li>
<li>Number 数字类型      控制台 蓝色  数字类型有两种</li>
<li>1.0-9之间的任意数字组合，可以是整数，也可以是小数，数字的范围在正无穷（+Infinity）和负无穷(-Infinity)之间</li>
<li>数字的最大值   Number.MAX_VALUE</li>
<li>数字的最小值   Number.MIN_VALUE</li>
<li>2.NaN</li>
<li>not a number</li>
<li>NaN 当运算失败的时候会出现NaN</li>
<li>console.log(NaN==NaN);//false  自己跟自己都不相等</li>
<li></li>
<li>Boolean 布尔值</li>
<li>true  真</li>
<li>false 假</li>
<li>布尔值只有两个值，但是它的应用非常广泛</li>
<li>做两个值判断的时候，要么真，要么假</li>
<li></li>
<li>Undefined  未定义</li>
<li>有且只有一个值，那就是 Undefined</li>
<li></li>
<li>Null 空</li>
<li>有且只有一个值，那就是Null</li>
<li>Null  和  Undefined 的区别</li>
<li>首先他们的值是不一样的，Undefined 表示当前的变量是有的，只是没有赋值</li>
<li>null 我当前的页面中获取的这个btn是页面当中没有的，所以它为空，压根就不存在</li>
<li></li>
<li>复杂类型  （引用类型）</li>
<li>Object  对象类型   它在系统中就用Object表示</li>
<li>格式：由简单的数据类型与复合数据类型任意组合而成的</li>
<li>它的数据是放在一对{}大括号内 每个数据又一对键值对组成</li>
<li>数据可以是0个也可以是多个，每个之间用逗号来隔开，最后一个数据不能加逗号</li>
<li></li>
<li>键值对   key:value</li>
<li>key  代表的数据名称,它可以加引号，也可以不加引号，但是当这个名字不符合变量命名规则的时候需要加引号</li>
<li>（数字除外），引号是成对出现    font-size   -   gril-friend </li>
<li>value 它是数据对应的值，这个值可以是简单数据类型，也可以是复杂数据类型</li>
<li></li>
<li>function函数  Date日期  Array数组 都属于引用类型（复杂类型）</li>
</ul>
<hr>
<p>day02 作业:用户输入任意两个数字点击交换按钮两个数值前后进行交替<br>             预习一下typeof   ‘a’ String  Number Boolean  Null Undefined  function(){} [‘a’,1,2,3,4] NaN<br>      console.log(typeof function(){});</p>
<pre><code>String   string
</code></pre><hr>
<p>任意类型转数字<br>Number()方法<br>1.Undefined<br>    转数字的结果是NaN<br>2.Null  0<br>3.Boolean<br>  true  1<br>  false 0<br>4.String<br>    空字符串   空格   0<br>    判读字符串的内容是不是纯数字，如果是纯数字，转化的结果就纯数字<br>    如果不是纯数字就是NaN<br>parseInt();把字符串转换为整型数字<br>parseFloat();把字符串转换为浮点型小数<br>toFixed();把Number的数字四舍五入为指定保留小数位的数字<br>isNaN();判断一个值是不是NaN,会提前把要转换的值进行Number()转换<br>如果值是NaN,那返回true</p>
<h2 id="如果值不是NaN-那返回false"><a href="#如果值不是NaN-那返回false" class="headerlink" title="如果值不是NaN,那返回false"></a>如果值不是NaN,那返回false</h2><p>任意类型转字符串</p>
<ul>
<li>String(要转换的值);</li>
<li>1.Undefined<pre><code>转字符串的结果是&apos;undefined&apos;
</code></pre>2.Null<br>   转为字符串的结果为’null’<br>3.Boolean<br>  true  ‘true’<br>  false ‘false’<br>4.String<br>   结果就是它本身</li>
<li>toString();</li>
</ul>
<hr>
<p>任意类型转布尔值</p>
<ul>
<li>Boolean(要转化的值)；</li>
<li>1.Undefined</li>
<li>转布尔值的结果 false</li>
<li>2.Null</li>
<li>false</li>
<li>3.Number转布尔值</li>
<li>0   false  </li>
<li>1   true</li>
<li>NaN false</li>
<li>Infinity   true</li>
<li>12  true</li>
<li>0/NaN转布尔值的结果为false</li>
<li>其他的转布尔值的结果为true</li>
<li></li>
<li>4.Boolean转布尔值</li>
<li>结果就是它本身</li>
<li></li>
<li>5.String转布尔值</li>
<li>villom   true</li>
<li>空               false </li>
<li>空格           true</li>
<li>空字符串转布尔值的结果为false，其他（包括空格字符串）转化的结果都为true</li>
</ul>
<hr>
<p>算数运算符</p>
<ul>
<li><ul>
<li><ul>
<li>/  %取模（求余数） ++ –<br>赋值运算符<br>= += -= *= /= %=<br>x+=y  x=x+y<br>关系运算符<br>&lt; &gt; &lt;= &gt;= != === !==<br>逻辑运算符<br>&amp;&amp; || ! a?b:c</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>作业：输入一个年份，判断该年份是否为闰年，闰年条件如下：<br> 能被4整除，但不能被100整除</p>
<h2 id="能被400整除"><a href="#能被400整除" class="headerlink" title=" 能被400整除"></a> 能被400整除</h2><p>流程语句<br>页面加载的顺序</p>
<ul>
<li>一般情况下，页面加载是从上到下，从左到右</li>
<li></li>
<li>if 如果</li>
<li>当代码有不同的情况需要去处理，这个时候就要用if</li>
<li>if 是关键字 不能用作变量名  函数  </li>
<li></li>
<li>语法</li>
<li>if(判断条件){</li>
<li>当判断条件成立的时候，会执行这里的代码</li>
<li><p>}</p>
</li>
<li><p>if     如果    当页面中只有一种特殊情况去处理的时候</p>
</li>
<li>else   否则    当页面中有两种特殊情况要去处理的时候</li>
<li></li>
<li>语法</li>
<li>if(判断条件){</li>
<li>//当条件成立的时候，执行这里的代码</li>
<li>}else{</li>
<li>//当条件判断不成立的时候，执行的代码</li>
<li>}</li>
</ul>
<p>if    如果    当页面中只有一种特殊情况去处理的时候</p>
<ul>
<li>else   否则    当页面中有两种特殊情况要去处理的时候</li>
<li>else if  否则如果   有多种特殊情况要去处理的时候</li>
<li></li>
<li>语法</li>
<li>if(判断条件1){</li>
<li>//当条件1成立的时候，执行这里的代码</li>
<li>}else if(判断条件2){</li>
<li>//当条件判断2成立的时候，执行的代码</li>
<li>}else{</li>
<li>//当以上的条件都不满足的时候，执行这里的代码</li>
<li>}</li>
<li></li>
<li>一个非0的转布尔值都会返回 n=10;赋值  n==10  = 赋值  ==比较  ===绝对等于</li>
</ul>
<p>作业：简易的留言板</p>
<h2 id="比较三个数字-求最大数"><a href="#比较三个数字-求最大数" class="headerlink" title="比较三个数字 求最大数"></a>比较三个数字 求最大数</h2><p>数组</p>
<ul>
<li>数组   Array </li>
<li>数据的组合</li>
<li></li>
<li>语法</li>
<li>[]</li>
<li>数据放在中括号里边，每个数据之间用逗号隔开，最后一个数据没有逗号,除了数字以外，数据是需要加引号的</li>
<li>每个数据都会对应一个下标，这个下标代表一个序号，下标是从0开始的</li>
<li>数组会有一个length属性，代表数组中数据的长度，这个length是动态的，它会随着数组中数据的变化而变化</li>
<li></li>
<li>下标代表的意思是，每个数据都有一个自己的标识，用于方便获取</li>
<li>下标的值从0开始</li>
<li></li>
<li>length:5  length 长度  代表数组中有几个数据</li>
<li></li>
<li>取数组中的某个数据</li>
<li>数组[下标值]</li>
<li>取第一个数组中的数据</li>
<li>color[0];</li>
<li>取最后一个数组中的数据</li>
<li>color[color.length-1];<br>   0      1        2      3       4<br>arr[‘red’,’green’,’yellow’,’blue’,’black’];<br>arr.length  5<br>arr[0]取第一个数据<br>arr[arr.length-1]取数组的最后一个数据<br>arr[3] 取blue</li>
</ul>
<hr>
<p>DOM的获取元素的方法<br>getElementById(id名称);<br>通过id来获取页面中的元素  获得元素是一个元素<br>主语：document</p>
<p>getElementsByTagName(标签名称);<br>通过HTML标签去获取元素<br>获取的是一组元素<br>主语<br>    document 从整个文档中去获取元素<br>          父级         从父级下面去获取元素<br>          它获取的是一组类数组   有length 属性  有下标</p>
<p>getElementsByClassName(class名称);<br>通过class去获取一组元素<br>主语<br>    document 从整个文档中去获取元素<br>         父级         从父级下面去获取元素<br>         它获取的是一组类数组   有length 属性  有下标</p>
<p>querySelector(“#  .”)<br>通过css选择器去获取一个元素   id #   class .<br>它获取到是一个元素，如果有重复情况，只取第一个<br>主语<br>    document 从整个文档中去获取元素<br>         父级         从父级下面去获取元素</p>
<p>querySelectorAll(“”);<br>通过css选择器去获取一组元素<br>它获取到的也是一组元素，也是一个类数组<br>主语<br>    document 从整个文档中去获取元素<br>         父级         从父级下面去获取元素  length属性   下标</p>
<hr>
<p>写一个函数，求1+3+5+7+…的前50项的和，n通过方法参数给定，和值通过函数返回返回值</p>
<h2 id="数字倒序排列-num-123456"><a href="#数字倒序排列-num-123456" class="headerlink" title="数字倒序排列   num=123456;"></a>数字倒序排列   num=123456;</h2><p> for循环</p>
<ul>
<li>根据一定的条件，重复执行一行或多行代码</li>
<li></li>
<li>语法</li>
<li>for(条件初始化;条件判断;条件变化){</li>
<li>当条件成立的时候（true）,重复执行这里的代码</li>
<li>}</li>
<li>分号不能少</li>
<li></li>
<li>for循环的一个步骤</li>
<li>第一步：条件初识话（声明了一个变量，给了这个变量一个初始值）</li>
<li>var i=0;</li>
<li></li>
<li>第二步：走的是条件判断（把变量的值限定在一个范围内）</li>
<li>i&lt;10;</li>
<li></li>
<li>第三步：走的是大括号里的代码（当条件判断成立的时候，走大括号里边的代码）</li>
<li>走不走取决于第二步的判断为true的时候才走</li>
<li>console.log(‘villom’);</li>
<li></li>
<li>第四步：条件变化（循环一次让变量的值加1）</li>
<li>i++;</li>
<li></li>
<li>注意  从第二次开始，它就不走第一步了，不断走第二步，第三步，第四步</li>
<li>变量声明一次就可以了，不会重复走</li>
<li></li>
<li>结束</li>
<li>当判断条件不成立的时候就结束循环，当i运行11次的时候条件为false，循环停止</li>
<li>循环什么时候结束，由判断条件来决定的</li>
<li>给条件的时候，一定要给一个能够结束的条件（循环结束的条件），否则就是一个死循环</li>
<li></li>
<li>循环什么时候用？</li>
<li>当需要操作一组元素做同一件事情的时候就用for循环</li>
</ul>
<hr>
<ul>
<li>for嵌套</li>
<li>有嵌套的循环，如果里边的循环没有走完的话，外面的循环是不会走的</li>
<li>外面的循环走一次，里边的循环走三次，当里边的循环走完所有的次数</li>
<li>才会跳到外面的循环</li>
<li></li>
<li>如果有嵌套的循环，那里边的变量一定不要与外面的变量相同，如果两个变量相同的话</li>
<li>里边的变量会把外面的变量给覆盖了</li>
</ul>
<hr>
<p>  this<br>  1.在函数外面的时候<br>    this指向window<br>  2.函数是直接被调用的<br>    this指向window<br>    被事件调用,并且是以赋值的形式出现<br>    this指向 谁调用它,this就指向谁</p>
<p> var lis=document.getElementsByTagName(“li”);<br> for(var i=0;i&lt;lis.length;i++){<br>     //0 1 2  3 4 5<br>     lis[i].onclick=function(){<br>         this.style.background=”red”;<br>     }</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=" }"></a> }</h2><p>  流程控制语句<br>  if(){</p>
<p>  }else if(){</p>
<p>  }else{</p>
<p>  }</p>
<p>  for(条件初始值;条件判断;条件变化){<br>      如果判断条件成立,重复执行这里的代码<br>  }<br>  第一步:条件初始值<br>  第二步:条件判断<br>  第三步:执行代码<br>  第四步:条件变化</p>
<p>  for(var 变量名  in 对象){<br>      这个对象可以是数组  对象<br>      变量名    对象里的属性名<br>      console.log(变量名)<br>      对象[属性名]  属性名对应的值<br>      console.log(对象[变量名]);<br>  }</p>
<p>  swich(变量){<br>      case 值:<br>      当这个值与变量的值相同的时候,执行这里的代码<br>      break;<br>      case 值:<br>      当这个值与变量的值相同的时候,执行这里的代码<br>      break;<br>      case 值:<br>      当这个值与变量的值相同的时候,执行这里的代码<br>      break;<br>      default:<br>      当以上变量都不满足的时候,执行的代码<br>    }</p>
<pre><code>while(判断条件){
    当条件成立的时候,执行的代码
    要写一个能让循环停止的条件,否则就是死循环
}

break  continue  return
参数
1.形参
  形式上的参数,放在函数名后面的小括号里,可以是0个或多个,中间用逗号隔开
2.实参
  实际上的参数,放在函数调用后面的括号里,形参有几个,实参就要有几个,如果形参有实参没有对应的值
  显示undefined 
</code></pre><hr>
<p>函数的类型及调用方式<br>1.函数声明<br>  语法<br>   function 函数名(参数){<br>        要执行的代码<br>   }<br>   调用:<br>   1.函数名(参数);<br>   2.把函数声明变成函数表达式,在后面加小括号<br>2.函数表达式<br>   语法<br>   var 变量=function(参数){<br>       要执行的代码<br>   }<br>   调用:<br>   1.变量();<br>   2.直接在函数后面加()小括号</p>
<p>//函数声明的第一种调用<br>function  fn(a,b){<br>   console.log(a+b);<br>}<br>fn(20,25);</p>
<p>(function  fn3(){<br>   console.log(‘这是函数声明的第二种调用方式’);<br>}());</p>
<p>!function  fn3(){//! + - ~<br>   console.log(‘这是函数声明的第二种调用方式’);<br>}();</p>
<p>//函数表达式的第一种调用<br>var fn1=function(a){<br>    console.log(a);<br>}<br>fn1(‘这是函数表达式的第一种调用方式’);</p>
<p>var fn2=function(){<br>    console.log(‘这是函数表达式的第二种调用方式’);</p>
<h2 id="-2"><a href="#-2" class="headerlink" title="}();"></a>}();</h2><p>函数返回值<br>return<br>函数运算的结果<br>1.返回函数的运算结果<br>  return 值;<br>  1.如果函数里边有return,那返回的结果就是return后面的值(函数运算完后的值);<br>  2.如果函数里边没有return,那返回的结果就是undefined<br>2.阻止后面函数的执行<br>  return 后面的代码是不执行的</p>
<p>  function fn(a,b,c){<br>      return a+b+c;//返回相加的值<br>  }<br>  fn(5,12,65);</p>
<p>  function fn1(a,b){<br>      var c=a+b;<br>      console.log(c);//25<br>      }<br>  fn1(10,15);</p>
<p>  function fn1(a,b){<br>      var c=a+b;<br>      return c;<br>   }</p>
<h2 id="console-log-fn1-10-15"><a href="#console-log-fn1-10-15" class="headerlink" title="  console.log(fn1(10,15));"></a>  console.log(fn1(10,15));</h2><p> 自定义属性<br> 字符串方法<br> charAt();通过索引值找字符<br> charCodeAt();通过索引找字符,找到后转成Unicode编码<br> indexOf(); 通过字符找下标<br> lastIndexOf();通过字符找下标,从右往左查到,查找的结果是真实的下标<br> slice();截取字符串  第一个参数是开始的位置,第二个是结束的位置  参数一含  参数二不含<br>         参数为负数的话,开始的位置是最后一位<br> split();用指定的分隔符把字符串转成数组   第一个参数分隔符  第二个分割成数组数据的个数<br>         没有参数,把整个字符串转为数组的一个数据<br>         一 个参数,这个参数是空字符,会把字符串作为数组中的一个数据,然后用逗号来隔开<br>         一个参数是空格,把整个字符串转为数组的一个数据<br>         两个参数 分隔后的数组的个数就是就是第二个参数的值<br>         如果这个参数是字符串中的某一个字符,以这个字符为分割符分开,然后把这个字符的前后分成两个数组的数据<br> subString();截取一段字符串    第一个参数 开始的位置  第二个参数结束的位置<br>         没有参数,返回整个字符串<br>         一个参数,从这个参数的位置一直截取到最后一个字符<br>         两个参数,从第一个参数的位置开始,到第二个参数的位置结束,含参数一不含参数二<br>         参数是负数,结果为空<br>与slice();的区别<br>    slice起始位置不能大于结束位置   subString的起始位置可以大于结束位置,它会把参数一和参数二进行调换<br>    slice可以放负数, subString的参数不可以放负数<br> substr();截取一段指定开始位置与个数的字符串<br>    参数一  开始的位置  start<br>    参数二  截取的个数   length<br>    没有参数  返回整个字符串<br>    一个参数 默认从参数一的位置开始到最后一个字符<br>    两个参数 从参数一的位置开始,输出参数二的个数的字符串<br>toLowerCase();把字符串转成小写<br>toUpperCase();把字符串转成大写<br>trim();去掉字符串首发空格<br>以上方法原字符串都不变</p>
<h3 id="页面加载的顺序"><a href="#页面加载的顺序" class="headerlink" title="页面加载的顺序"></a>页面加载的顺序</h3><pre><code> * 一般情况下，页面加载是从上到下，从左到右
 * 
 * if 如果
 * 当代码有不同的情况需要去处理，这个时候就要用if
 * if 是关键字 不能用作变量名  函数  
 * 
 * 语法
 * if(判断条件){
 *      当判断条件成立的时候，会执行这里的代码
 * }
 * 
 * if的条件成立不成立它是怎么知道的
 * true  false 是布尔值
 * 
 * 1&lt;2  true
 * &lt;  要么小  要么小
 * 
 * 
 * 
 * 
 * 
 */
/*if(1&lt;2){
    //当1&lt;2的条件成立，这里的代码才会执行
    alert(&quot;成立&quot;);
}*/
if(1&lt;0){
    //1&lt;0 是不成立的，所以这里的代码不会执行
    alert(&quot;不成立&quot;);
}
//alert(1&lt;2);true
//alert(1&gt;2);false
</code></pre><h3 id="if-如果-当页面中只有一种特殊情况去处理的时候"><a href="#if-如果-当页面中只有一种特殊情况去处理的时候" class="headerlink" title="if     如果    当页面中只有一种特殊情况去处理的时候"></a>if     如果    当页面中只有一种特殊情况去处理的时候</h3><pre><code> * else   否则    当页面中有两种特殊情况要去处理的时候
 * 
 * 语法
 * if(判断条件){
 *     //当条件成立的时候，执行这里的代码
 * }else{
 *     //当条件判断不成立的时候，执行的代码
 * }
 * 
 * 
 * 
 */
if(1&gt;2){
    //条件满足的，执行
    alert(&quot;成立&quot;);
}else{
    //当上面的条件不满足的时候，执行
    alert(&quot;不成立&quot;);
}
</code></pre><p>###数组</p>
<pre><code>* 数组   Array 
* 数据的组合
* 
* 语法
* []
* 数据放在中括号里边，每个数据之间用逗号隔开，最后一个数据没有逗号,除了数字以外，数据是需要加引号的
* 每个数据都会对应一个下标，这个下标代表一个序号，下标是从0开始的
* 数组会有一个length属性，代表数组中数据的长度，这个length是动态的，它会随着数组中数据的变化而变化
* 
* 下标代表的意思是，每个数据都有一个自己的标识，用于方便获取
* 下标的值从0开始
* 
* length:5  length 长度  代表数组中有几个数据
* 
* 取数组中的某个数据
* 数组[下标值]
* 取第一个数组中的数据
* color[0];
* 取最后一个数组中的数据
* color[color.length-1];
</code></pre><p>###getElementById(id名称)</p>
<pre><code>* 通过id名称去获取一个元素，document代表整个文档，代表的是一个页面
* 主语
*   document  从整个文档中去获取一个元素
* getElementById它前面的主语只有document
* 
* getElementsByTagName(标签名称);
* 通过html标签获取一组元素，它获取到的是一组元素
* 主语：
*    document  从整个文档中去获取一组元素
*    父级             从父级下面去获取一组元素
*    它获取到的是一组几个，是类数组
*    它只具有数组中的length属性，以及每个数据都会有一个自己对应的下标
* 
*    HTMLCollection集合
*    getElementsByClassName(class名称);
* 通过class去获取一组元素
* 获取到的结果也是一个类数组   有length  有下标   
* 
* 主语：
*   document  从整个文档去获取一组元素
*   父级             从父级下面去获取一组元素
* 
* getElementsByClassName  有兼容问题
* querySelector
* 通过css选择器去获取一个元素
* 它获取到的是一个元素，如果说有重复的，那它只取第一个
* 
* 主语：
*   document   从整个文档里获取元素
*   父级               从父级下去获取元素
</code></pre><p>###for循环</p>
<pre><code>* 根据一定的条件，重复执行一行或多行代码
* 
* 语法
* for(条件初始化;条件判断;条件变化){
*      当条件成立的时候（true）,重复执行这里的代码
* }
* 分号不能少
* 
* for循环的一个步骤
* 第一步：条件初识话（声明了一个变量，给了这个变量一个初始值）
*        var i=0;
* 
* 第二步：走的是条件判断（把变量的值限定在一个范围内）
*        i&lt;10;
* 
* 第三步：走的是大括号里的代码（当条件判断成立的时候，走大括号里边的代码）
*        走不走取决于第二步的判断为true的时候才走
*        console.log(&apos;villom&apos;);
* 
* 第四步：条件变化（循环一次让变量的值加1）
*        i++;
* 
* 注意  从第二次开始，它就不走第一步了，不断走第二步，第三步，第四步
*     变量声明一次就可以了，不会重复走
* 
* 结束
*    当判断条件不成立的时候就结束循环，当i运行11次的时候条件为false，循环停止
*    循环什么时候结束，由判断条件来决定的
*    给条件的时候，一定要给一个能够结束的条件（循环结束的条件），否则就是一个死循环
* 
* 循环什么时候用？
*    当需要操作一组元素做同一件事情的时候就用for循环
</code></pre><p>###定时器</p>
<pre><code>* setInterval()
* 作用
*   每隔一段时间就回去执行指定的函数，重复的执行
* 语法
*   setInterval(function(){
*       每隔一段时间就会执行这里的代码
* },时间)
* 参数
*   1.要执行的函数，当时间到了就会执行
*     注意：如果函数在外面定义的，这里边调用的话，只能写函数的名字，不能加括号
*   2.时间：间隔的时间
*     单位：毫秒
*     1s=1000ms
*     2.延迟执行定时器
*   setTimeout()
*   作用
*      当延迟时间到达后，会执行这里的函数，这个函数只执行一次
*   语法
*      setTimeout(function(){
*                        当时间到达后，会执行这里的代码
*      },时间)
</code></pre><p>###时间对象</p>
<pre><code> * js中自带的一个内置方法，用于处理日期与时间相关的操作
 * 
 * 创建日期对象
 * new Date();
 *    创建一个跟日期有关系的对象
 *  星期一   Monday
 *  星期二  Tuesday
 *  星期三  wednesday
 *  星期四  Thursday
 *  星期五  Friday
 *  星期六  Saturday
 *  星期日  Sunday
 *  
 * new Date()里可以接收参数
 * 1.没有参数
 *   它是以本机的时间作为参考，创建一个日期对象
 * 2.new Date(年,月,日,时,分,秒);
 *   参数是数字，每个参数用逗号来隔开
 *   注意：参数是可以省略的，不一定要全部写，省略的部分会默认为0，除了日期，日期的默认为1
 * 3.new Date(&apos;June 10,2013 12:12:12&apos;); 
 *   参数是字符串，外国人常用的日期表达方式
 * 4.new Date(时间戳);
 *   参数是时间戳
 *   时间戳：从1970年1月1日0时0分0秒，到指定一个时间点之间的毫秒数
 * 
 * 注意：你拿到的date对象只是本机的时间，修改的话修改的是date对象的日期，而不是本机的日期，本机的日期只能获取不能修改
 * 
 */
var d1=new Date();
console.log(d1);
//Wed Nov 29 2017 14:15:21 GMT+0800 (中国标准时间)
//星期   月份  日期  年      时     分    秒    GMT 格林尼治时间  世界的标准时间 0800 东八区    

var d2=new Date(2017,5,8,15,29,23);
console.log(d2);
//Thu Jun 08 2017 15:29:23 GMT+0800 (中国标准时间)
//Fri Jun 16 2017 05:23:00 GMT+0800 (中国标准时间)

var d3=new Date(&apos;June 10,2013 12:12:12&apos;);
console.log(d3);
//Mon Jun 10 2013 12:12:12 GMT+0800 (中国标准时间)

var d4=new Date(new Date().getTime());
console.log(d4);
//Mon Jun 10 2013 12:12:12 GMT+0800 (中国标准时间)

var d5=new Date().getTime();
console.log(d5);
//1511937428768 获取到的是当前毫秒的时间戳
</code></pre><p>###事件</p>
<pre><code>*    当发生某一个动作的时候触发的一个函数
*    
* 鼠标事件
*    点击事件
*    移入移出事件
* 键盘事件
*    游戏当中会用到键盘事件
* 系统   window.onload
* 表单事件
*     change
* 事件在系统当中是不加on的，在书写的时候加上on，on是调事件的一种方式
* 
* mouseover  mouseout 事件传递，它会把事件传递给子级
* mouseenter  mouseleave不会有事件传递，给父级添加的事件是不会传递给子级的
</code></pre><p>###事件流</p>
<pre><code>* 事件流是指事件在触发时的一个流程，就像for循环一样有一个执行的过程
* 在事件触发时，会先执行一个阶段叫做“捕获阶段”，从最外层向触发该元素寻找的一个过程，
* 最终找到触发该事件的元素，如果该元素有绑定事件处理函数则执行该函数，
* 在找到触发该事件的元素之后，如果元素身上有事件，就会执行事件，称为“目标阶段”
* 接下来会进入到下一阶段“冒泡阶段”，冒泡阶段是从目标元素的上一层开始往外寻找，直到
* 最外层时结束整个事件流程
* 
* 无论是捕获阶段还是冒泡阶段，在寻找目标元素的过程中和向外返回的过程中，所遇到的每一个元素
* 身上如果有同一个事件处理函数都会被调用
* 
* 事件的整个流程 三个阶段
* 
* 捕获阶段   capture 从外往里找，不管你点击的是哪一个元素，它都会从最高级window找起，一层一层往下走
* 目标阶段   target  第二个阶段
* 冒泡阶段  bubbling 从里往外走
* 
* 
* 注意：IE浏览器的低版本只能绑定在冒泡阶段
* 阻止冒泡
*     1.阻止on事件   
*       event.cancelBubble=true;属性
*     2.阻止addEventListener事件
*       event.stopPropagation();方法
* 
*   5.浏览器的默认行为
*     1.去除on事件的默认行为   
*       在函数里边写   return false;
*     2.去除addEventListener事件的默认行为     
*       在函数里调用  event.preventDefault();方法
*     3.去除拖拽
*       元素.ondragstart=function(){return false};
*     4.去除右击
*       元素.oncontextmenu=function(){return false};
</code></pre><p>###拖拽原理</p>
<pre><code>* 1.鼠标按下 mousedown
* 
*   需要计算出鼠标点击的地方离元素边界的距离
*   鼠标起始X轴的距离=event.clientX-box.offsetLeft;
*   鼠标起始Y轴的距离=event.clientY-box.offsetTop;
*  
* 2.鼠标移动 mousemove
* 
*   算出元素的真正的left值和top值
*   box.style.left=event.clientX-鼠标起始X轴的距离;
*   box.style.top=event.clientY-鼠标起始Y轴的距离;
* 
* 
* 3.鼠标抬起 mouseup
*   清除鼠标身上的事件，清空事件，为后面做铺垫
</code></pre><p>###正则</p>
<pre><code>* 字符串
* [] 中括号里边任意字符   [a-z]  
* [^]不在中括号内的任意字符[^aa]
* .  除换行符和其它unicode终止符外的任意字符
* \w （小写）任何Ascii码字符组成的单词等价于    [a-zA-Z0-9_]
* \W  任何不是Ascii码表字符组成的单词[^a-zA-Z0-9]
* \s  空白符  [\f\n\r\t\v]
* \S  任何非unicode空白符的字符
* \d  数字[0-9]
* \D  [^0-9]
* [\b]退格直接量
* 
* 重复
* {n,m}匹配前一项至少n次 最多匹配m次  c{2,5} 匹配c至少是两次  不能超过5次
* {n,} 匹配前一项n次或者跟多次
* {n}  匹配前一项n次
* ?  匹配前一项0次或者1次  等价于{0,1}
* +  匹配前一项一次或多次  至少是一次&gt;=1  {1,}
* *  匹配前一项0次或多次  等价于{0,}
* 
* 选择分组
* | 选择匹配的是该表达式的左边的子表达式或者右边的子表达式
* ()分组 代表括号里边是子选项，每一个小括都可以看做是一个子项
* \n换行  转译符号
* 
* 锚字符
* ^ 正则表达式开头
* $ 正则表达式结尾
* \b 匹配一个字边界，即字与空格间的位置  位于字符\w和\W之间的位置或者位于字符\w字符串的开头或结尾的位置
* \B 非字边界匹配
* 
* 修饰符 只能写在//后面
* g 全局匹配
* i 执行忽略大小写的匹配
* m 多行匹配模式
</code></pre><p>###jQuery<br>作用域<br>只有函数和变量有作用域，其它的没有<br>变量或者函数的可访问的一个范围，以函数来划分，一个函数快就一个作用域</p>
<p>变量作用域范围</p>
<ol>
<li>全局作用域<br>全局：整个文档 document<br>变量或者函数在函数外面声明，它们就是全局变量和全局函数<br>全局的作用范围是整个范围，在这个页面的任何地方都可以访问到他们<br>声明全局作用域的方法</li>
<li>把变量或者函数放在函数 外声明</li>
<li>变量不用var声明，直接给变量赋值（只针对全局变量）<br>不管是函数外还是函数内声明，没有var就是一个全局变量<br>之所以全局变量在任何地方都可以访问到，是因为全局变量是window的属性<br>Window是一个全局对象，它本身在页面中的任何位置都可以用，所以说全局变量在任何地方都可以用<br>注意：尽量避免使用没有var全局变量，声明变量的时候一定要加var，不建议大家使用没有var的全局变量<br>因为变量是window身上的属性，在不了解window身上有哪些属性的时候，最好不要使用，因为有可能它会把原来的window身上的一些属性给覆盖掉</li>
</ol>
<p>局部作用域<br>局部：函数范围  只能在自己的范围内用<br>变量或者函数只在函数内部声明，它的作用仅存在于声明的函数里<br>函数（函数声明，不是函数调用）函数是可以嵌套的，嵌套的函数就是局部作用域（局部函数）可以访问到父级函数里边的内容<br>作用域是说你声明的变量是在函数声明的里边，而不是函数调用的里边</p>
<p>声明局部作用域的方法<br>局部作用域分两个  一个是局部变量  一个是局部函数<br>var   变量的声明<br>function 函数名（）{}  函数声明</p>
<p>jquery是JavaScript库<br>angular<br>jquery把常用的一些功能给封装好了，我们只需要按它规定的api方法去调用就可以了<br>我们不需要关心它是怎么样写的，你只需要关心它提供的这个方法是干嘛的就可以了</p>
<p>提供了很强大的选择器，简洁的api  优雅的链式   便捷的操作<br>核心理念  写的少  做的多</p>
<p>3个大版本<br>1字开头的做了很多低版本IE兼容处理  IE6<br>2字开头的基本抛弃了低版本（IE9以下的）<br>3字开头的2字开头的基础上加了很多新的功能</p>
<p>http：//jquery.com英文官网<br>http：//www. jquery123.com  中文的网站<br>后面带min说明是压缩过的文件，在官网里有compr<br>jquery是放在一个匿名函数自执行，<br>好处<br>1使用匿名函数自执行，创建一个私有（封闭）的空间，这样内部打的命名空间就不会相互干扰<br>这样可以避免全局污染<br>2把window作为参数传进来<br>  1是便于代码压缩，有时候关键字是没有办法压缩的<br>  2兼容模块化写法，在浏览器的环境下，给factory传入的是window<br>  3可以节省查找全局window的时间，提高性能，封闭的空间内就有window，自己找自己的window<br>3 noGlobal为undefined，确保undefined可以使用<br>在低版本undefined会被修改的，函数不传参数就是undefined</p>
<p>js中加载用的window.onload=function（）{}<br>jquery 加载<br>语法<br>$(callBack);<br>$(document).ready(callback);<br>$(). ready(callback);<br>以上三种方法在页面中都可以写，表示页面全部加载完成以后。再执行这里的代码<br>jquery获取元素的方法<br>语法<br>$（selector）；selector选择器 css怎么写这里就怎么写</p>
<p>jquery获取到的所有的元素都是集合</p>
<p>jquery里的事件没有on<br>语法<br>$（元素）.click（callBack）<br>在这个事件里的this是原生的，如果要用this转成jQuery的形式$（this）<br>在jquery获取的所有元素都是集合</p>
<p>css（）方法<br>关于样式的一些操作<br>一个参数，获取属性的值<br>一个参数，如果这个参数是对象，表示设置属性，同时可以设置多个属性的值<br>两个参数，是设置属性的值</p>
<p>表单的value值<br>$（元素）.val（）不带参数是获取value值<br>.val（value）带参数的是设置value值</p>
<p>attr（）<br>关于标签属性的操作<br>一个参数，表示获取元素的某个属性<br>参数的值就是属性的名字<br>两个参数设置元素的某个属性<br>两个参数第一个参数为属性名字，第二个参数为属性要设置的值</p>
<p>data（）给标签添加数据<br>有参数的话是添加数据（用对象的形式去表示）<br>没有参数的话是获取数据</p>
<p>html（）原生里的innerHTML作用是一样的<br>text()</p>
<p>链式操作<br>对一个原素进行连续的操作</p>
<p>Js获取节点是通过DOM方法<br>jquery获取节点<br>.first（）获取第一个子节点<br>.last（）获取最后一个子节点<br>.slice（start，end）截取部分子节点<br>      start 截取开始的位置<br>      end 结束的位置 不包含结束位置<br>第二个参数不写，从第一个参数开始截至最后一位<br>.children（）获取到元素里边的第一层子节点<br>   没有参数的话获取到的是父级下的所有子节点<br>   有参数的话，参数是一个选择器，找到的是对应的选择的节点<br>.find（）获取元素里的所有节点</p>
<p>父节点<br>.parent（）元素的第一层父节点<br>.parents（）元素的所有的父节点，它会一层一层往外找，直到找到嘴歪层的父节点</p>
<p>最近的节点<br>.closest（selector）从自身开始找，一层一层往外找，找到最近的满足条件就不找了</p>
<p>创建节点与插入节点<br>父级.append（要添加的元素）把要添加的元素添加到父级的最后面<br>父级.prepend（要添加的元素）把要添加的元素添加到父级的最前面<br>元素.before（要添加的元素）把要添加的元素添加到指定的元素的前面<br>元素.after（要添加的元素）把要添加的元素添加到指定的元素的后面</p>
<p>要添加的元素.append To（父级）把要添加的元素添加到父级的最后面<br>要添加的元素.insertBefore（元素）把要添加的元素添加到元素的最前面<br>要添加的元素. .insertAfter（元素）把要添加的元素添加到指定的元素的后面<br>要添加的元素.prepend（父级）把要添加的元素添加到指定的父级的前面</p>
<p>remove（）删除节点<br>元素.remove（）<br>clone（blooen）克隆元素<br>参数默认为空   表示只复制元素不复制事件<br>如果参数为true 表示元素与事件都会被复制</p>
<p>上一个兄弟节点<br>.prev（）<br>下一个兄弟节点<br>.next（）</p>
<p>index（）索引<br>没有 参数<br>第一个元素（获取到的元素，因为jQuery获取到的是一组）在兄弟元素中的排行<br>有参数<br>   代表前面的元素在参数的标签（所有标签，不分兄弟）里排行<br>返回-1说明没有找到</p>
<p>each（i，elem）循环方法<br>i 每个元素对应的下标（索引）<br>elem每个元素  原生的元素</p>
<p>eq（index）通过索引找对应的元素<br> index 参数为下标</p>
<p>get（index）把jquery对象转原生对象<br>原生转jquery对象用$（）<br>jquery转原生对象用get（index）</p>
<p>包装对象：在外面包一层标签<br>wrap（）在标签外面加一层父级<br>wrapAll（）把所有的标签拿过来放在一起，给他的外面加一层父级是根据第一个标签来定结构的<br>wrapInner（）在父级里添加一个标签，并把内容放在这个标签里面<br>unwrap（）删除父级</p>
<p>不带单位<br>width（）获取元素的宽度<br>height（）获取元素的高度</p>
<p>outerwidth（）相当于原生的offsetWidth<br>outerwidth（）相当于原生的offsetHeight</p>
<p>innerWidth（）  width+padding<br>innerHeight（） height+padding</p>
<p>页面的宽高<br>$(document).width()<br>$(document).height()<br>可视区的宽高<br>$(window).width()<br>$(window).heught()</p>
<p>获取元素的位置<br>offset（）.Left相当于原生了的getBoundingClientRect<br>offset（）.top<br>元素相对父级的距离<br>position（）.left 相当于原生的的offsetLeft<br>position（）.top<br>offsetParent（）  找到最近的有定位的父级</p>
<p>scrollTop（）滚动条的高度<br>scrollLeft（）滚动条的宽度<br>没有参数，代表获取滚动条距离<br>有参数代表设置滚动条的距离</p>
<p>jquery的事件<br>通过eddEventListener添加的事件<br>几个事件是同时加载，是不会被覆盖的</p>
<p>jquery写好的运动库，只留给方法，会用就可以<br>show（duration，easing，complate）显示<br>hide（duration，easing，complate）隐藏</p>
<p>duration  时间<br>      Slow   600毫秒  慢<br>Normal 400毫秒  正常<br>Fast   200毫秒   快<br>easing  运动的方式<br>   linear  匀速<br>   swing  缓冲<br>complate 运动完成之后的回调函数</p>
<p>toggle（duration，easing，complate）在两种效果之间切换<br>toggle它会参考display的值，让运动在显示和隐藏之间切换，它在运动时会切换宽高透明度等属性</p>
<p>fadeIn（duration，easing，complate）显示<br>fadeOut（duration，easing，complate）隐藏<br>fadeToggle（duration，easing，complate）</p>
<p>收缩与展开<br>slideUp（duration，easing，complate）收缩<br>slideDown（duration，easing，complate）展开<br>slideToggle（duration，easing，complate）显示</p>
<p>animate（property，duration，easing，complate）<br>property  要运动的属性   它是一个对象<br>duration  运动的时间<br>easing    运动方式<br>          Linear  匀速<br>          Swing  缓冲<br>complate  回调函数</p>
<p>stop（）停止动画<br>stop（）没有参数，只停止当前属性的运动，后面的运动不会走<br>stop（true）有参数所有的运动都停止了<br>stop（true，true）当前的运动会直接走到目标点，后面的运动不会走<br>finish（）停止，不接受参数，所有的属性都会马上到达目标点，没有运动效果，后面的运动并不会走<br>问题移入移出的时候触发多次，它就必须运行多少次<br>stop（），解决办法：在鼠标放上去的时候，先让当前的运动停止了<br>plugins 插件<br>validate 表单插件<br>rules  代表规则<br>required 表示是否要验证true要验证 false 不用验证用户名</p>
<p>###ajax<br>ajax是运行在服务器上的<br>name是用来提交数据的</p>
<p>action 表单提交地址   取name的值<br>method 就是提交的方式<br>         get<br>         提交的数据通过地址栏发送，数据添加到地址栏的问号后面<br>         数据形式：数据名=数据值&amp;数据名=数据值<br>         post<br>         提交的数据通过请求头发送（头部信息，能通过控制台看到）<br>XHR是ajax的一个对象</p>
<p>ajax是一种技术方案，但不是一种新技术，它依赖现有的css/HTML/javascript,而其中最核心的依赖的是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发HTTP请求与接收HTTP响应</p>
<p>ajax：Asynchronous  JavaScript  and  XML（异步js和XML）<br>异步js：js的代码都是从上到下执行的，如果一块代码没有执行完毕，那后面的代码就不会执行<br>异步就是ajax可以不按顺序执行</p>
<p>XML：存储数据的一种格式</p>
<p><name>张三</name></p>
<p><age>30</age></p>
<p><qq>245687923</qq></p>
<p><email>256454526.qq.com</email><br>ajax不光能处理XML格式的数据，还可以处理json数组字符串类型的数据</p>
<p>ajax到底能干嘛？<br>Js与后端进行数据交互的一种技术，通过请求协商好的接口，来获取想要的数据</p>
<p>优点：<br>传输数据时会在本页面请求服务器，不用跳转页面，从而减轻服务器的压力，做到实时验证，减少用户返工率并且优化用户体验</p>
<p>ajax必须是运行在服务器环境当中<br>ajax是基于HTTP(HTTPS)协议，只能在HTTP服务器环境下运行<br>本地协议的协议 file协议<br>www目录下的文件夹不能以中文命名，但是文件里的html文件可以用中文命名<br>localhost相当于www目录<br>ajax数据交互流程<br>1创建一个ajax对象   第一步   买电话<br>2填写请求地址        第二部   输入号码<br>3发送请求    第三步拨号<br>4等待服务器响应  第四步等待<br>5接收数据    第五步  通话</p>
<p>XMLttpRequest  这个对象身上有一个open方法<br>第一个参数   请求方式   get post<br>第二个参数   地址<br>第三个参数   同步还是异步，true表示异步请求</p>
<p>get<br>1.通过地址栏信息进行数据传输，传输的大小有限制<br>ajax.open(‘get’,’php/get_json.php?user=’+val,true);<br>2.不安全，用户的所有信息都会暴露<br>3拼接数据的时候要用encodeURI转码，不然中文就会乱码<br>4不用设置请求头<br>5数据的拼接在open方法里<br>6会有缓存问题</p>
<p>post<br>1通过send向服务器传输数据，理论上来说是没有长度或者体积的限制<br>ajax.send（）<br>2相对安全，不暴露用户信息<br>3不用转码，已经通过请求头设置了数据格式，不会乱码<br>ajax。setRequestHeader(‘Content-Type’,’application/x-www-form-urlencoed’)<br>4在send（）的面前需设置一个请求头（不设置会报错）<br>5数据拼接要在send的方法里<br>6没有缓存问题</p>
<p>面试题<br>同步与异步<br>同步1当send方法调用后会等待服务器返回信息，如果服务器一直没有响应就会阻塞后面的代码，后面的代码就不会执行<br>2后面的代码的执行受前面代码的影响，后面的代码不执行<br>异步<br>1当send方法调用后就会执行后面的代码，不用等待服务器的响应<br>2后面的代码不受前面代码的影响</p>
<p>ajax.readyState  ajax运行步骤（第一步是捕捉不到的）<br>它的值为4的话说明ajax已经运行完成<br>0初始化  还没有调用open（）方法<br>1载入    已经调用open（）方法<br>2载入完成   send（）方法完成，以收到全部响应<br>3解析   正在解析响应内容<br>4完成   响应内容解析完成，可以在客户端使用<br>服务器<br>ajax.Status   服务器对请求的反馈（状态码）<br>200就是成功的   404就是错误  400 505<br>404请求的资源没有 找到</p>
<p>onreadystatechange<br>   readyState的值变化的时候触发<br>上传只能用post方式，并且后台需要处理中文<br> ajax.upload.onprogress   上传文件的进度<br> ev.loaded         已经上传文件的大小<br> ev.total          总文件的大小</p>
<p> formDate                 创建于表单格式相同的数据,他是由XMLHttpRequest  2级定义，获取到是一个二进制数据</p>
<p>  formDate.append(文件名，文件值)</p>
<p>  files    上传选中文件的所有列表,放在type为file的表单空间中<br>  这里包括：最后修改的时间，大小，类型等等。</p>
<p> 跨域<br> 两个不同域名下的数据进行交互，ajax之所以不能跨域其实是因为XMLHttpRequest受到同源策略的限制，<br> 只能访问同源下的数据，不能访问不同源下的数据<br>  同源策略<br>  每个网站只能读取同一来源的数据。这里的同一来源值得是主机名（域名）‘协议（httptps）和端口号的组合<br>  在没有明确授权的情况下，不能读写对方的资源，他是浏览器最核心最基本的安全功能<br>  源：协议，端口，域名<br>  只要不同源就跨域</p>
<p>  协议<br>  http  超文本协议<br>  https HTTPS协议是由ssl+http协议构建的可进行加密传输，身份认证的网络协议  要比http安全<br>  file  本地协议<br>  ftp   文件共享协议</p>
<p>  域名 <a href="http://www.kaivon.cn/" target="_blank" rel="noopener">http://www.kaivon.cn/</a><br>  <a href="http://www.kaivon.cn/c/d.html" target="_blank" rel="noopener">http://www.kaivon.cn/c/d.html</a>   成功<br>  <a href="http://www.kaivon.cn/c/d/f.html" target="_blank" rel="noopener">http://www.kaivon.cn/c/d/f.html</a>   成功<br>  <a href="https://www.kaivon.cn/c.html" target="_blank" rel="noopener">https://www.kaivon.cn/c.html</a>   协议不同<br>  <a href="http://www.kaivon.cn:81/a/c.html" target="_blank" rel="noopener">http://www.kaivon.cn:81/a/c.html</a>   失败  端口不同<br>  <a href="http://www.apeclass.com/a/b.html" target="_blank" rel="noopener">http://www.apeclass.com/a/b.html</a>  失败  主机名不同</p>
<p>  跨域解决办法<br>  1，在标准浏览器下XMLHttpRequest配合后台设置一个请求权限<br>     在php里写  header(‘Access-Control-Allow-Origin:’);<br>    这个是XMLHttpRequest 2级支持的，非标准浏览器不支持<br>  2，服务器代理<br>     服务器文件可以访问你想要的资源，而你又能访问服务器文件，所以你就可以访问想要的资源<br>     缺点：如果想要访问的资源有变化，对于后端的开发成本就很大<br>  3.iframe,flash,postMesssage,WabSocket<br><a href="http://www.freebuf.con/articles/web/65468.html" target="_blank" rel="noopener">http://www.freebuf.con/articles/web/65468.html</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/09/“技术总结”/" data-id="cjdg1t01c0000tcv5wdosw0zt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/01/23/my/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">my</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/09/“技术总结”/">“技术总结”</a>
          </li>
        
          <li>
            <a href="/2018/01/23/my/">my</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>